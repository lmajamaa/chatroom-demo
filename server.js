// @remove-on-eject-begin
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */
// @remove-on-eject-end
'use strict';

// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
  throw err;
});

// Ensure environment variables are read.
require('./node_modules/react-scripts-ts/config/env');

const fs = require('fs');
const chalk = require('chalk');
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const {
  choosePort,
  createCompiler,
  prepareProxy,
  prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');
const openBrowser = require('react-dev-utils/openBrowser');
const paths = require('./node_modules/react-scripts-ts/config/paths');
const config = require('./node_modules/react-scripts-ts/config/webpack.config.dev');
const createDevServerConfig = require('./node_modules/react-scripts-ts/config/webpackDevServer.config');

const useYarn = fs.existsSync(paths.yarnLockFile);
const isInteractive = process.stdout.isTTY;

// Warn and crash if required files are missing
if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
  process.exit(1);
}

// Tools like Cloud9 rely on this.
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';

// We attempt to use the default port but if it is busy, we offer the user to
// run on a different port. `detect()` Promise resolves to the next free port.
choosePort(HOST, DEFAULT_PORT)
  .then(port => {
    if (port == null) {
      // We have not found a port.
      return;
    }
    const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
    const appName = require(paths.appPackageJson).name;
    const urls = prepareUrls(protocol, HOST, port);
    // Create a webpack compiler that is configured with custom messages.
    const compiler = createCompiler(webpack, config, appName, urls, useYarn);
    // Load proxy config
    const proxySetting = require(paths.appPackageJson).proxy;
    const proxyConfig = prepareProxy(proxySetting, paths.appPublic);
    // Serve webpack assets generated by the compiler over a web sever.
    const serverConfig = createDevServerConfig(
      proxyConfig,
      urls.lanUrlForConfig
    );
    const devServer = new WebpackDevServer(compiler, serverConfig);
    // Launch WebpackDevServer.
    devServer.listen(port, HOST, err => {
      if (err) {
        return console.log(err);
      }
      if (isInteractive) {
        clearConsole();
      }
      console.log(chalk.cyan('Starting the development server...\n'));
      openBrowser(urls.localUrlForBrowser);
    });

    ['SIGINT', 'SIGTERM'].forEach(function(sig) {
      process.on(sig, function() {
        devServer.close();
        process.exit();
      });
    });
  })
  .catch(err => {
    if (err && err.message) {
      console.log(err.message);
    }
    process.exit(1);
  });


const io = require('socket.io')();
var ioPort = 3001;

// Default rooms
var channels = ['general', 'development', 'random', 'project x'];

// User names handling
var userNames = (function () {
  var names = {};

  var claim = function (name) {
    if (!name || names[name]) {
      return false;
    } else {
      names[name] = true;
      return true;
    }
  };

  // Assign guest name and claim it
  var getGuestName = function () {
    var name,
      nextUserId = 1;

    do {
      name = 'User ' + nextUserId;
      nextUserId += 1;
    } while (!claim(name));

    return name;
  };

  // Serialize claimed names as an array
  var get = function () {
    var res = [];
    for (user in names) {
      res.push(user);
    }

    return res;
  };

  // Free names
  var free = function (name) {
    if (names[name]) {
      delete names[name];
    }
  };

  return {
    claim: claim,
    free: free,
    get: get,
    getGuestName: getGuestName
  };
}());

// Retrieve users on current channel
function getUsersOnChannel(channel) {
  var list = [];

  for (var clientID in io.sockets.connected) {
    var socket = io.sockets.connected[clientID];
    if(socket.channel == channel) {
      list.push(socket.username)
    }
  }
  return list
}

// Retrieve specific user by name
function findTargetUser(user) {
  var client = '';

  for (var clientID in io.sockets.connected) {
    var socket = io.sockets.connected[clientID];
    if(socket.username == user) {
      client = socket.id;
    }
  }
  return client;
}

// Connection
io.on('connection', function (socket) {
  var name = userNames.getGuestName();
  socket.username = name;
  var address = socket.handshake.address;
  socket.channel = 'general'
  socket.join(socket.channel);
  
  // Init
  socket.emit('init', {
    name: name,
    channel: socket.channel,
    channels: channels,
    users: getUsersOnChannel(socket.channel)
  });
  
  console.log(name + ' joined channel #' + socket.channel);
  socket.emit('channelUpdate', {
    user: "Server",
    date: new Date(),
    text: 'You have joined channel #' + socket.channel,
    users: getUsersOnChannel(socket.channel)
  });
  
  // Inform others that user has joined
  socket.to(socket.channel).emit('user:join', {
    name: name,
    address: address
  });

  // Disconnect
  socket.on('disconnect', function () {
    socket.to(socket.channel).emit('user:left', {
      name: name
    });
    userNames.free(name);
  });
  
  // Message
  socket.on('user:message', function(data){
    console.log('#' + socket.channel + ' ' + socket.username + ': ' + data.text);
    socket.to(socket.channel).emit('user:message', {
      user: name,
      date: new Date(),
      text: data.text
    });
  });
  
  // Change channel functionality
  socket.on('user:changeChannel', function(channelName){
    
    // Leave old channel
    socket.leave(socket.channel);
    console.log(name + ' left channel #' + socket.channel);
    socket.to(socket.channel).emit('user:message', {
      user: "Server",
      date: new Date(),
      text: name + ' has left channel #' + socket.channel
    });
    
    // Inform other users that user has left
    socket.to(socket.channel).emit('user:left', {
      name: name
    });
    
    // Join new channel
    socket.channel = channelName;
    socket.join(socket.channel);
    console.log(name + ' joined channel #' + socket.channel);
    socket.emit('channelUpdate', {
      user: "Server",
      date: new Date(),
      text: 'You have joined channel #' + socket.channel,
      users: getUsersOnChannel(socket.channel)
    });
    
    // Inform other users that new user has joined
    socket.to(socket.channel).emit('user:message', {
      user: "Server",
      date: new Date(),
      text: name + ' has joined channel #' + socket.channel
    });
    
    // Send join message to user
    socket.to(socket.channel).emit('user:join', {
      name: name,
      address: address
    });
  });
  
  // New channel
  socket.on('user:newChannel', function(channelName){
    channels.push(channelName);
    console.log('New channel created by user ' + name + ' :  #' + socket.channel);
  });
    
  // Private message
  socket.on("user:privateMessage", function(data) {
    console.log('Private message from ' + data.user + ' to ' + data.to);
    var clientID = findTargetUser(data.to);
    io.sockets.connected[clientID].emit("user:privateMessage", {
      user: data.user,
      to: clientID,
      text: data.text
    });
   });
  
  //Name change - may fail if name is already in use
  socket.on('user:changeName', function(data, fn) {
    if (userNames.claim(data.name)) {
      var oldName = name;
      userNames.free(oldName);

      name = data.name;
      socket.username = data.name;
      socket.broadcast.emit('user:changeName', {
        oldName: oldName,
        newName: name
      });
      // Inform other users that user has changed name
      socket.to(socket.channel).emit('user:message', {
        user: "Server",
        date: new Date(),
        text: oldName + ' has changed name to ' + name
      });
      
      fn(true);
    } else {
      fn(false);
    }
  });
});

// Start
io.listen(ioPort);
console.log('Socket.io listening on *:port %d', ioPort);
